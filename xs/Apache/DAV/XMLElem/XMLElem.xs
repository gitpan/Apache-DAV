
/*
 * *********** WARNING **************
 * This file generated by Apache::DAV::WrapXS/0.01
 * Any changes made here will be lost
 * ***********************************
 * 1. /opt/perl5.6.1/lib/site_perl/5.6.1/ExtUtils/XSBuilder/WrapXS.pm:38
 * 2. /opt/perl5.6.1/lib/site_perl/5.6.1/ExtUtils/XSBuilder/WrapXS.pm:1898
 * 3. xsbuilder/xs_generate.pl:6
 */


#include "mod_dav.h"

#include "EXTERN.h"

#include "perl.h"

#include "XSUB.h"

#include "moddav_xs_sv_convert.h"

#include "moddav_xs_typedefs.h"



void Apache__DAV__XMLElem_new_init (pTHX_ Apache__DAV__XMLElem  obj, SV * item, int overwrite) {

    SV * * tmpsv ;

    if (SvTYPE(item) == SVt_PVMG) 
        memcpy (obj, (void *)SvIVX(item), sizeof (*obj)) ;
    else if (SvTYPE(item) == SVt_PVHV) {
        if ((tmpsv = hv_fetch((HV *)item, "name", sizeof("name") - 1, 0)) || overwrite) {
            const char * tmpobj = ((const char *)davxs_sv2_PV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> name = (const char *)strdup(tmpobj);
            else
                obj -> name = NULL ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "ns", sizeof("ns") - 1, 0)) || overwrite) {
            obj -> ns = (int)davxs_sv2_IV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "lang", sizeof("lang") - 1, 0)) || overwrite) {
            const char * tmpobj = ((const char *)davxs_sv2_PV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> lang = (const char *)strdup(tmpobj);
            else
                obj -> lang = NULL ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "parent", sizeof("parent") - 1, 0)) || overwrite) {
            obj -> parent = (struct dav_xml_elem *)davxs_sv2_Apache__DAV__XMLElem((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "next", sizeof("next") - 1, 0)) || overwrite) {
            obj -> next = (struct dav_xml_elem *)davxs_sv2_Apache__DAV__XMLElem((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "first_child", sizeof("first_child") - 1, 0)) || overwrite) {
            obj -> first_child = (struct dav_xml_elem *)davxs_sv2_Apache__DAV__XMLElem((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "attr", sizeof("attr") - 1, 0)) || overwrite) {
            obj -> attr = (struct dav_xml_attr *)davxs_sv2_Apache__DAV__XMLAttr((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "last_child", sizeof("last_child") - 1, 0)) || overwrite) {
            obj -> last_child = (struct dav_xml_elem *)davxs_sv2_Apache__DAV__XMLElem((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "propid", sizeof("propid") - 1, 0)) || overwrite) {
            obj -> propid = (int)davxs_sv2_IV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "provider", sizeof("provider") - 1, 0)) || overwrite) {
            obj -> provider = (const dav_hooks_liveprop *)davxs_sv2_Apache__DAV__HooksLiveprop((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
   ; }

    else
        croak ("initializer for Apache::DAV::XMLElem::new is not a hash or object reference") ;

} ;


MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

const char *
name(obj, val=NULL)
    Apache::DAV::XMLElem obj
    const char * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (const char *)  obj->name;

    if (items > 1) {
        obj->name = (const char *)strdup(val);
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

int
ns(obj, val=0)
    Apache::DAV::XMLElem obj
    int val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (int)  obj->ns;

    if (items > 1) {
        obj->ns = (int) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

const char *
lang(obj, val=NULL)
    Apache::DAV::XMLElem obj
    const char * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (const char *)  obj->lang;

    if (items > 1) {
        obj->lang = (const char *)strdup(val);
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

Apache::DAV::TextHeader
first_cdata(obj, val=NULL)
    Apache::DAV::XMLElem obj
    Apache::DAV::TextHeader val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (Apache__DAV__TextHeader) & obj->first_cdata;
    if (items > 1) {
         croak ("first_cdata is read only") ;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

Apache::DAV::TextHeader
following_cdata(obj, val=NULL)
    Apache::DAV::XMLElem obj
    Apache::DAV::TextHeader val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (Apache__DAV__TextHeader) & obj->following_cdata;
    if (items > 1) {
         croak ("following_cdata is read only") ;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

Apache::DAV::XMLElem
parent(obj, val=NULL)
    Apache::DAV::XMLElem obj
    Apache::DAV::XMLElem val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (Apache__DAV__XMLElem)  obj->parent;

    if (items > 1) {
        obj->parent = (Apache__DAV__XMLElem) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

Apache::DAV::XMLElem
next(obj, val=NULL)
    Apache::DAV::XMLElem obj
    Apache::DAV::XMLElem val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (Apache__DAV__XMLElem)  obj->next;

    if (items > 1) {
        obj->next = (Apache__DAV__XMLElem) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

Apache::DAV::XMLElem
first_child(obj, val=NULL)
    Apache::DAV::XMLElem obj
    Apache::DAV::XMLElem val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (Apache__DAV__XMLElem)  obj->first_child;

    if (items > 1) {
        obj->first_child = (Apache__DAV__XMLElem) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

Apache::DAV::XMLAttr
attr(obj, val=NULL)
    Apache::DAV::XMLElem obj
    Apache::DAV::XMLAttr val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (Apache__DAV__XMLAttr)  obj->attr;

    if (items > 1) {
        obj->attr = (Apache__DAV__XMLAttr) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

Apache::DAV::XMLElem
last_child(obj, val=NULL)
    Apache::DAV::XMLElem obj
    Apache::DAV::XMLElem val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (Apache__DAV__XMLElem)  obj->last_child;

    if (items > 1) {
        obj->last_child = (Apache__DAV__XMLElem) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

int
propid(obj, val=0)
    Apache::DAV::XMLElem obj
    int val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (int)  obj->propid;

    if (items > 1) {
        obj->propid = (int) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 

Apache::DAV::HooksLiveprop
provider(obj, val=NULL)
    Apache::DAV::XMLElem obj
    Apache::DAV::HooksLiveprop val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (Apache__DAV__HooksLiveprop)  obj->provider;

    if (items > 1) {
        obj->provider = (Apache__DAV__HooksLiveprop) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::DAV::XMLElem    PACKAGE = Apache::DAV::XMLElem 



SV *
new (class,initializer=NULL)
    char * class
    SV * initializer 
PREINIT:
    SV * svobj ;
    Apache__DAV__XMLElem  cobj ;
    SV * tmpsv ;
CODE:
    davxs_Apache__DAV__XMLElem_create_obj(cobj,svobj,RETVAL,malloc(sizeof(*cobj))) ;

    if (initializer) {
        if (!SvROK(initializer) || !(tmpsv = SvRV(initializer))) 
            croak ("initializer for Apache::DAV::XMLElem::new is not a reference") ;

        if (SvTYPE(tmpsv) == SVt_PVHV || SvTYPE(tmpsv) == SVt_PVMG)  
            Apache__DAV__XMLElem_new_init (aTHX_ cobj, tmpsv, 0) ;
        else if (SvTYPE(tmpsv) == SVt_PVAV) {
            int i ;
            SvGROW(svobj, sizeof (*cobj) * av_len((AV *)tmpsv)) ;     
            for (i = 0; i <= av_len((AV *)tmpsv); i++) {
                SV * * itemrv = av_fetch((AV *)tmpsv, i, 0) ;
                SV * item ;
                if (!itemrv || !*itemrv || !SvROK(*itemrv) || !(item = SvRV(*itemrv))) 
                    croak ("array element of initializer for Apache::DAV::XMLElem::new is not a reference") ;
                Apache__DAV__XMLElem_new_init (aTHX_ &cobj[i], item, 1) ;
            }
        }
        else {
             croak ("initializer for Apache::DAV::XMLElem::new is not a hash/array/object reference") ;
        }
    }
OUTPUT:
    RETVAL 

PROTOTYPES: disabled

BOOT:
    items = items; /* -Wall */

