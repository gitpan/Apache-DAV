# 
# /*
#  * *********** WARNING **************
#  * This file generated by Apache::DAV::WrapXS/0.01
#  * Any changes made here will be lost
#  * ***********************************
#  * 1. /opt/perl5.6.1/lib/site_perl/5.6.1/ExtUtils/XSBuilder/WrapXS.pm:38
#  * 2. /opt/perl5.6.1/lib/site_perl/5.6.1/ExtUtils/XSBuilder/WrapXS.pm:1898
#  * 3. xsbuilder/xs_generate.pl:6
#  */
# 


package Apache::DAV::Resource;
require DynaLoader ;
use strict ;
use vars qw{$VERSION @ISA} ;

push @ISA, 'DynaLoader' ;
$VERSION = '0.01';
bootstrap Apache::DAV::Resource $VERSION ;


use Apache::Array ;
use Apache::DAV;
use Apache::DAV::PropsResult;
use Apache::DAV::XMLDoc;
use Apache::DAV::XMLAttr;
use Apache::DAV::XMLElem;
use Apache::DAV::Text;
use Apache::DAV::TextHeader;
use Apache::DAV::HooksLocks;
use Apache::DAV::LockDB;
use Apache::DAV::Error;

use vars qw{@obj} ;

sub print_tag
    {
    my ($e) = @_ ;

    print '<', $e -> name, '>', "\n" ;
    my $t = $e -> first_cdata ;
    if ($t)
        {
        my $txt = $t -> first ;
        while ($txt)
            { 
            print $txt -> text, "\n" ;
            $txt = $txt -> next ;
            }
        }

    print_tags ($e -> first_child) ;

    print '</', $e -> name, '>', "\n" ;
    }


sub print_tags
    {
    my ($e) = @_ ;

    while ($e)
        {
        print_tag ($e) ;
        $e = $e -> next ;
        }
    }



sub create_xml_prop

    {
    my ($r, $set, $remove) = @_ ;

    my $nsid = 0 ;
    my %namespaces ;
    my @set ;
    my @remove ;
    #my @obj ;
    @obj = () ;
    my $setprop ;
    my $setelem ;
    my $removeprop ;
    my $removeelem ;


    $namespaces{'DAV:'} = $nsid++ ;

    if (keys %$set)
        {
        $setprop = Apache::DAV::XMLElem -> new ({name => 'prop'}) ;
        foreach (keys %$set)
            {
            my ($ns, $name) ;
            ($ns, $name) = ('DAV:', $_) if (!(($ns, $name) = /^(.*):(.*?)$/)) ;
            $ns   = 'DAV:' if ($ns eq 'DAV' || !$ns) ;
            $name = '???' if (!$name) ;
            $namespaces{$ns} = $nsid++ if (!exists $namespaces{$ns}) ;
        
            my $text   = Apache::DAV::Text -> new ({ text => $set -> {$_} });
            my $elem   = Apache::DAV::XMLElem -> new ({name => $name, ns => $namespaces{$ns},}) ; 
            my $header = $elem -> first_cdata;
            $header->first($text);
            $header->last ($text);
            $set[-1] -> next($elem) if (@set) ;
            $elem->parent($setprop);
            push @set, $elem ;
            push @obj, $elem, $text ;
            }            
        $setprop -> first_child($set[0]) ;
        $setprop -> last_child($set[-1]) ;
        $setelem  = Apache::DAV::XMLElem -> new ({name        => 'set', 
                                                      first_child => $setprop,
                                                      last_child  => $setprop,
                                                      });
        $setprop->parent($setelem);
        push @obj, $setprop, $setelem ;
        }
        
            
    if (keys %$remove)
        {
        $removeprop = Apache::DAV::XMLElem -> new ({name => 'prop'}) ;
        foreach (keys %$remove)
            {
            my ($ns, $name) ;
            ($ns, $name) = ('DAV:', $_) if (!(($ns, $name) = /^(.*):(.*?)$/)) ;
            $ns   = 'DAV:' if ($ns eq 'DAV' || !$ns) ;
            $name = '???' if (!$name) ;
            $namespaces{$ns} = $nsid++ if (!exists $namespaces{$ns}) ;
        
            my $elem = Apache::DAV::XMLElem -> new ({name => $name, ns => $namespaces{$ns},}) ; 
            $remove[-1] -> next($elem) if (@remove) ;
            $elem->parent($removeprop);
            push @remove, $elem ;
            push @obj, $elem ;
    
            }            
        $removeprop -> first_child($remove[0]) ;
        $removeprop -> last_child($remove[-1]) ;
        $removeelem  = Apache::DAV::XMLElem -> new ({name        => 'remove', 
                                                      first_child => $removeprop,
                                                      last_child  => $removeprop,
                                                      });
        $removeprop->parent($removeelem);
        push @obj, $removeprop, $removeelem ;
        #print "remove: " ; print_tags ($removeelem) ;
        }
    
    
    my $xml_elem_propertyupdate ;
    if ($setelem || $removeelem)
        {
        $xml_elem_propertyupdate = Apache::DAV::XMLElem -> new ({name => 'propertyupdate',
                                                          first_child => $setelem || $removeelem,
                                                          last_child  => $removeelem || $setelem,
                                                          });

        push @obj, $xml_elem_propertyupdate ;
        $setelem->parent($xml_elem_propertyupdate) if ($setelem) ;
        $removeelem->parent($xml_elem_propertyupdate) if ($removeelem) ;
        $setelem->next($removeelem) if ($removeelem && $setelem) ;
        }


    #print_tags ($xml_elem_propertyupdate) ;

    my @ns ;
    foreach (keys %namespaces)
        {
        $ns[$namespaces{$_}] = $_ ;
        #print "namespace = #$namespaces{$_}  $_\n" ;
        }


    my $namespaces = Apache::Array::make_array ($r, @ns+1, 4) ;
    push @obj, $namespaces ;
    push @obj, \@ns ;
        
    foreach (@ns)
        {
        $namespaces -> insert_uri ($_) ;
        #print "namespace = $_\n" ;
        }

    my $xml_doc = Apache::DAV::XMLDoc -> new ({root => $xml_elem_propertyupdate, namespaces => $namespaces}) ; 
    #print "root name = ", $xml_doc -> root -> name, "\n" ;
    #print "root ns = ", $xml_doc -> root -> ns, "\n" ;
    push @obj, $xml_doc ;

    return $xml_doc ;
    }


sub jointext

    {
    my ($textobj) = @_ ;
    my $text = '' ;

    while ($textobj)
        { 
        $text .=  $textobj -> text, "\n" ;
        $textobj = $textobj -> next ;
        }
    
    return $text ;
    }


sub text2hash 
    {
    my ($xml_stats, $namespaces) = (@_) ;
    
    $xml_stats =~ /<D:prop>\s*(.*)\s*<\/D:prop>/s ;
    my $props = $1 ;
    my %props ;

    while ($props =~ m#<([^\s>]*)(\s[^>]*)?>\s*(.*?)\s*</\1>#gs)
        {
        my ($ns, $name) = split /:/, $1 ;
        my $namespace = ($namespaces -> {$ns} || $ns) ;
        my $val = $3 ;
        $namespace =~ s/([^:]$)/$1:/ ;
        $props{$namespace . $name} = $val ;
        }

    return \%props ;
    }




sub proppatch
    {
    my ($resource, $r, $set, $remove) = @_ ;
 
    my $doc = create_xml_prop ($r, $set, $remove) ;
    
    my ($status, $text) = $r -> proppatch ($resource, $doc) ;

    return ($status, jointext ($text)) ;    
    }


sub propfind
    {
    my ($resource, $r) = @_ ;

    my $lockdb ;
    my $propdb ;
    my $err ;
    
    ($err, $lockdb)   =  $r -> open_lockdb (0) ;
    die 'ERROR in open_lockdb (' . $err->status . '): ' . $err->desc if ($err) ;

    ($err, $propdb)   =  $r -> open_propdb ($lockdb, $resource, 1) ;
    die 'ERROR in open_propdb (' . $err->status . '): ' . $err->desc if ($err) ;

    my $props = $propdb -> get_allprops (1) ;

    $propdb -> close_propdb if ($propdb) ;
    $lockdb -> hooks -> close_lockdb ($lockdb) if ($lockdb) ;

    return 1 if (!$props) ;

    my %namespaces ;
    my $ns = $props -> xmlns ;
    while ($ns)
        { 
        $ns -> text =~ /xmlns:(.*?)=\"(.*?)\"/ ;
        $namespaces{$1} = $2 ;
        $ns = $ns -> next ;
        }
    

    return (0, jointext ($props -> propstats), \%namespaces) ;    
    }


sub propfind_hash
    {
    my ($resource, $r) = @_ ;

    my ($status, $text, $ns) = $resource -> propfind ($r) ;
    my $props ;

    if (!$status)
        {
        $props = text2hash ($text, $ns) ;
        }

    return ($status, $props) ;
    }



sub info
    {
    my ($resource, $r) = @_ ;

    print 'URI: ', $r->uri,  "\n" ;
    my $resuri = $resource->uri;
    printf("URI %s exists%s.\n", $resuri, ($resource->exists?'':' not'));
    printf("URI %s is %s collection.\n", 
  	   $resuri, ($resource->collection?'a':'no'));
    printf("URI %s is%s versioned%s.\n", 
  	   $resuri, 
  	   ($resource->versioned?'':' not'), 
  	   ($resource->working?' and has revision '.$resource->working:''));
    printf("URI %s is%s baselined.\n", 
  	   $resuri, ($resource->baselined?'':' not'));

    print "\nLockDB Path" , $r->get_lockdb_path, "\n" ;

  
    }



1;
__END__
