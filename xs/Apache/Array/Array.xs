
/*
 * *********** WARNING **************
 * This file generated by Apache::DAV::WrapXS/0.01
 * Any changes made here will be lost
 * ***********************************
 * 1. /opt/perl5.6.1/lib/site_perl/5.6.1/ExtUtils/XSBuilder/WrapXS.pm:38
 * 2. /opt/perl5.6.1/lib/site_perl/5.6.1/ExtUtils/XSBuilder/WrapXS.pm:1898
 * 3. xsbuilder/xs_generate.pl:6
 */


#include "mod_dav.h"

#include "EXTERN.h"

#include "perl.h"

#include "XSUB.h"

#include "moddav_xs_sv_convert.h"

#include "moddav_xs_typedefs.h"



void Apache__Array_new_init (pTHX_ Apache__Array  obj, SV * item, int overwrite) {

    SV * * tmpsv ;

    if (SvTYPE(item) == SVt_PVMG) 
        memcpy (obj, (void *)SvIVX(item), sizeof (*obj)) ;
    else if (SvTYPE(item) == SVt_PVHV) {
        if ((tmpsv = hv_fetch((HV *)item, "elt_size", sizeof("elt_size") - 1, 0)) || overwrite) {
            obj -> elt_size = (int)davxs_sv2_IV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "nelts", sizeof("nelts") - 1, 0)) || overwrite) {
            obj -> nelts = (int)davxs_sv2_IV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "nalloc", sizeof("nalloc") - 1, 0)) || overwrite) {
            obj -> nalloc = (int)davxs_sv2_IV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "elts", sizeof("elts") - 1, 0)) || overwrite) {
            char * tmpobj = ((char *)davxs_sv2_PV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)));
            if (tmpobj)
                obj -> elts = (char *)ap_pstrdup(obj -> pool, tmpobj);
            else
                obj -> elts = NULL ;
        }
   ; }

    else
        croak ("initializer for Apache::Array::new is not a hash or object reference") ;

} ;


MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

Apache::Array
ap_append_arrays(arg0, arg1, arg2)
    Apache::Pool arg0
    Apache::Array arg1
    Apache::Array arg2

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void
ap_array_cat(dst, src)
    Apache::Array dst
    Apache::Array src

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

char *
ap_array_pstrcat(p, arr, sep)
    Apache::Pool p
    Apache::Array arr
    const char sep

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void
ap_clear_table(arg0)
    Apache::Table arg0

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

Apache::Array
ap_copy_array(p, src)
    Apache::Pool p
    Apache::Array src

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

Apache::Array
ap_copy_array_hdr(p, src)
    Apache::Pool p
    Apache::Array src

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

Apache::Table
ap_copy_table(p, arg1)
    Apache::Pool p
    Apache::Table arg1

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

Apache::Array
ap_make_array(r, nelts, elt_size)
    Apache r
    int nelts
    int elt_size
CODE:
    RETVAL = ap_make_array(r->pool, nelts, elt_size);
OUTPUT:
    RETVAL


MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

Apache::Table
ap_make_table(p, nelts)
    Apache::Pool p
    int nelts

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void
ap_overlap_tables(a, b, flags)
    Apache::Table a
    Apache::Table b
    unsigned flags

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

Apache::Table
ap_overlay_tables(p, overlay, base)
    Apache::Pool p
    Apache::Table overlay
    Apache::Table base

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void *
ap_push_array(arg0)
    Apache::Array arg0

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void
ap_table_add(arg0, name, val)
    Apache::Table arg0
    const char * name
    const char * val

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void
ap_table_addn(arg0, name, val)
    Apache::Table arg0
    const char * name
    const char * val

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

const char *
ap_table_get(arg0, arg1)
    Apache::Table arg0
    const char * arg1

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void
ap_table_merge(arg0, name, more_val)
    Apache::Table arg0
    const char * name
    const char * more_val

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void
ap_table_mergen(arg0, name, more_val)
    Apache::Table arg0
    const char * name
    const char * more_val

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void
ap_table_set(arg0, name, val)
    Apache::Table arg0
    const char * name
    const char * val

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void
ap_table_setn(arg0, name, val)
    Apache::Table arg0
    const char * name
    const char * val

MODULE = Apache::Array    PACKAGE = Apache::Array   PREFIX = ap_

void
ap_table_unset(arg0, key)
    Apache::Table arg0
    const char * key

MODULE = Apache::Array    PACKAGE = Apache::Array 

int
elt_size(obj, val=0)
    Apache::Array obj
    int val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (int)  obj->elt_size;

    if (items > 1) {
        obj->elt_size = (int) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::Array    PACKAGE = Apache::Array 

int
nelts(obj, val=0)
    Apache::Array obj
    int val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (int)  obj->nelts;

    if (items > 1) {
        obj->nelts = (int) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::Array    PACKAGE = Apache::Array 

int
nalloc(obj, val=0)
    Apache::Array obj
    int val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (int)  obj->nalloc;

    if (items > 1) {
        obj->nalloc = (int) val;
    }
  OUTPUT:
    RETVAL

MODULE = Apache::Array    PACKAGE = Apache::Array 

char *
elts(obj, val=NULL)
    Apache::Array obj
    char * val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (char *)  obj->elts;

    if (items > 1) {
        obj->elts = (char *)ap_pstrdup(obj -> pool, val);
    }
  OUTPUT:
    RETVAL

MODULE = Apache::Array    PACKAGE = Apache::Array 



SV *
new (class,initializer=NULL)
    char * class
    SV * initializer 
PREINIT:
    SV * svobj ;
    Apache__Array  cobj ;
    SV * tmpsv ;
CODE:
    davxs_Apache__Array_create_obj(cobj,svobj,RETVAL,malloc(sizeof(*cobj))) ;

    if (initializer) {
        if (!SvROK(initializer) || !(tmpsv = SvRV(initializer))) 
            croak ("initializer for Apache::Array::new is not a reference") ;

        if (SvTYPE(tmpsv) == SVt_PVHV || SvTYPE(tmpsv) == SVt_PVMG)  
            Apache__Array_new_init (aTHX_ cobj, tmpsv, 0) ;
        else if (SvTYPE(tmpsv) == SVt_PVAV) {
            int i ;
            SvGROW(svobj, sizeof (*cobj) * av_len((AV *)tmpsv)) ;     
            for (i = 0; i <= av_len((AV *)tmpsv); i++) {
                SV * * itemrv = av_fetch((AV *)tmpsv, i, 0) ;
                SV * item ;
                if (!itemrv || !*itemrv || !SvROK(*itemrv) || !(item = SvRV(*itemrv))) 
                    croak ("array element of initializer for Apache::Array::new is not a reference") ;
                Apache__Array_new_init (aTHX_ &cobj[i], item, 1) ;
            }
        }
        else {
             croak ("initializer for Apache::Array::new is not a hash/array/object reference") ;
        }
    }
OUTPUT:
    RETVAL 

PROTOTYPES: disabled

BOOT:
    items = items; /* -Wall */

